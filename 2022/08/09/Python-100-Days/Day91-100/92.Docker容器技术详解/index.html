<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>92.Docker容器技术详解 | HExLL</title><meta name="keywords" content="Python,Day91-100"><meta name="author" content="GreenSeaa"><meta name="copyright" content="GreenSeaa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Docker容器技术详解 Docker是基于Go语言开发的开源应用容器引擎，遵从Apache Licence 2.0协议，可以让开发者打包应用以及应用的依赖包到一个可移植的容器中，然后发布到各种发行版本的Linux系统上。 Docker简介 软件开发中最为麻烦的事情可能就是配置环境了。由于用户使用的操作系统具有多样性，即便使用跨平台的开发语言（如Java和Python）都不能保证代码能够在各种平台">
<meta property="og:type" content="article">
<meta property="og:title" content="92.Docker容器技术详解">
<meta property="og:url" content="https://yuanweize.github.io/2022/08/09/Python-100-Days/Day91-100/92.Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="HExLL">
<meta property="og:description" content="Docker容器技术详解 Docker是基于Go语言开发的开源应用容器引擎，遵从Apache Licence 2.0协议，可以让开发者打包应用以及应用的依赖包到一个可移植的容器中，然后发布到各种发行版本的Linux系统上。 Docker简介 软件开发中最为麻烦的事情可能就是配置环境了。由于用户使用的操作系统具有多样性，即便使用跨平台的开发语言（如Java和Python）都不能保证代码能够在各种平台">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-08-09T05:39:48.000Z">
<meta property="article:modified_time" content="2022-08-09T15:08:27.563Z">
<meta property="article:author" content="GreenSeaa">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Day91-100">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuanweize.github.io/2022/08/09/Python-100-Days/Day91-100/92.Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"SW7OVVVFHX","apiKey":"5d05023a8579462e72ea704e4f43cf3f","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '92.Docker容器技术详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '09-08-2022 17:08:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s.gravatar.com/avatar/50de7ee8a1fc96ada7495a641400642d?s=512" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">59</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://app.plex.tv/"><i class="fa-fw fas fa-music"></i><span> Movie[PLEX]</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HExLL</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://app.plex.tv/"><i class="fa-fw fas fa-music"></i><span> Movie[PLEX]</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">92.Docker容器技术详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-09T05:39:48.000Z" title="发表于 09-08-2022 07:39:48">09-08-2022</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-09T15:08:27.563Z" title="更新于 09-08-2022 17:08:27">09-08-2022</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python-100-Days/">Python-100-Days</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python-100-Days/Day91-100/">Day91-100</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="92.Docker容器技术详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Docker容器技术详解">Docker容器技术详解</h2>
<p>Docker是基于Go语言开发的开源应用容器引擎，遵从Apache Licence 2.0协议，可以让开发者打包应用以及应用的依赖包到一个可移植的容器中，然后发布到各种发行版本的Linux系统上。</p>
<h3 id="Docker简介">Docker简介</h3>
<p>软件开发中最为麻烦的事情可能就是配置环境了。由于用户使用的操作系统具有多样性，即便使用跨平台的开发语言（如Java和Python）都不能保证代码能够在各种平台下都可以正常的运转，而且在不同的环境下我们安装的软件需要依赖的软件包也是不一样的。</p>
<p>那么问题来了，我们安装软件的时候可不可以把软件运行的环境一并安装？我们是不是可以把原始环境一模一样地复制过来呢？</p>
<p>虚拟机（virtual machine）就是带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统，在macOS上运行Windows，而应用程序对此毫无感知。使用过虚拟机的人都知道，虚拟机用起来跟真实系统一模一样，而对于虚拟机的宿主系统来说，虚拟机就是一个普通文件，不需要了就删掉，对宿主系统或者其他的程序并没有影响。但是虚拟机通常会占用较多的系统资源，启动和关闭也非常的缓慢，总之用户体验并没有想象中的那么好。</p>
<p>Docker属于对Linux容器技术（LXC）的一种封装（利用了Linux的namespace和cgroup技术），它提供了简单易用的容器使用接口，是目前最流行的 Linux 容器解决方案。Docker将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。下图是虚拟机和容器的对比，左边是传统的虚拟机，右边是Docker。</p>
<p><img src="./res/docker_vs_vm.png" alt=""></p>
<p>目前，Docker主要用于几下几个方面：</p>
<ol>
<li>提供一次性的环境。</li>
<li>提供弹性的云服务（利用Docker很容易实现扩容和收缩）。</li>
<li>实践微服务架构（隔离真实环境在容器中运行多个服务）。</li>
</ol>
<h3 id="安装Docker">安装Docker</h3>
<p>下面以CentOS为例讲解如何安装Docker，使用<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a>、<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/install/">macOS</a>或<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/install/">Windows</a>的用户可以通过点击对应的链接了解这些平台下如何进行安装。</p>
<ol>
<li>
<p>确定操作系统内核版本（CentOS 7要求64位，内核版本3.10+；CentOS 6要求64位，内核版本2.6+）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更新系统底层的库文件（建议一定要执行，否则在使用Docker时可能会出现莫名其妙的问题）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>移除可能存在的旧的Docker版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list installed | grep docker</span><br><span class="line">yum erase -y docker docker-common docker-engine</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装yum工具包和依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过yum工具包添加yum源（安装Docker-ce的源）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在CentOS下使用yum安装Docker-ce并启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看Docker的信息和版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>接下来可以通过下载镜像和创建容器来看看Docker是否可以运转起来。可以使用下面的命令从Docker的镜像仓库下载名为hello-world的镜像文件。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure>
<p>查看所有镜像文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY               TAG        IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/hello-world    latest     fce289e99eb9        7 months ago        1.84 kB</span><br></pre></td></tr></table></figure>
<p>通过镜像文件创建并运行容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run --name mycontainer hello-world</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：其中<code>mycontainer</code>是我们给容器起的名字，跟在<code>--name</code>参数之后；<code>hello-world</code>就是我们刚才下载的镜像文件。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>
<p>如果要删除这个容器，可以使用下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container rm mycontainer</span><br></pre></td></tr></table></figure>
<p>在删除容器之后，我们还可以删除刚才下载的镜像文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi hello-world</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：如果要在Ubuntu（内核版本3.10+）下面安装和启动Docker，可以按照如下的步骤进行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install docker-ce</span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure>
<p>国内用户可以通过更换Ubuntu软件下载源来提升下载速度，具体请参照清华大学开源软件镜像站上的<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">《Ubuntu镜像使用帮助》</a>。</p>
</blockquote>
<p>安装Docker后，由于直接访问<a target="_blank" rel="noopener" href="https://hub.docker.com/">dockerhub</a>下载镜像会非常缓慢，建议将服务器更换为国内镜像，可以通过修改 <code>/etc/docker/daemon.json</code> 文件来做到。一般的云服务器会有自己专属的镜像，就不需要手动修改了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Docker">使用Docker</h3>
<p>想要玩转Docker，最简单的办法就是马上用Docker创建一些自己学习和工作中需要用到的容器，下面我们带着大家一起来创建这些容器。</p>
<h4 id="运行Nginx">运行Nginx</h4>
<p>Nginx是高性能的Web服务器，同时也是做反向代理服务器的上佳选择。使用Docker可以非常简单的创建一个运行Nginx的容器，命令如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run -d -p 80:80 --rm --name mynginx nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：上面的参数<code>-d</code>表示容器在后台运行（不产生输出到Shell）并显示容器的ID；<code>-p</code>是用来映射容器的端口到宿主机的端口，冒号前面是宿主机的端口，冒号后面是容器内部使用的端口；<code>--rm</code>表示容器停止后自动删除容器，例如执行命令<code>docker container stop mynginx</code>后，容器就不复存在了；<code>--name</code>后面的mynginx是自定义的容器名字；在创建容器的过程中，需要用到nginx的镜像文件，镜像文件的下载是自动完成的，如果没有指定版本号，默认是最新版本（latest）。</p>
</blockquote>
<p>如果需要将自己的Web项目（页面）部署到Nginx上，可以使用容器拷贝命令将指定路径下所有的文件和文件夹拷贝到容器的指定目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container cp /root/web/index.html mynginx:/usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p>如果不愿意拷贝文件也可以在创建容器时通过数据卷操作<code>--volume</code>将指定的文件夹映射到容器的某个目录中，例如将Web项目的文件夹直接映射到<code>/usr/share/nginx/html</code>目录。我们先通过下面的命令让刚才创建的容器停止运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container stop mynginx</span><br></pre></td></tr></table></figure>
<p>然后用下面的命令重新创建容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run -d -p 80:80 --rm --name mynginx --volume /root/docker/nginx/html:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：上面创建容器和拷贝文件的命令中，<code>container</code>是可以省略的，也就是说<code>docker container run</code>和<code>docker run</code>是一样的，而<code>docker container cp</code>和<code>docker cp</code>是一样的。此外，命令中的<code>--volume</code>也可以缩写为<code>-v</code>，就如同<code>-d</code>是<code>--detach</code>的缩写，<code>-p</code>是<code>--publish</code>的缩写。<code>$PWD</code>代表宿主系统当前文件夹，这些对于使用过Unix或者Linux系统的人来说，应该是很容易理解的。</p>
</blockquote>
<p>要查看运行中的容器，可以使用下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONTAINER ID    IMAGE    COMMAND                  CREATED            STATUS             PORTS                 NAMES</span><br><span class="line">3c38d2476384    nginx    &quot;nginx -g &#x27;daemon ...&quot;   4 seconds ago      Up 4 seconds       0.0.0.0:80-&gt;80/tcp    mynginx</span><br></pre></td></tr></table></figure>
<p>要启动和停止容器，可以使用下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start mynginx</span><br><span class="line">docker stop mynginx</span><br></pre></td></tr></table></figure>
<p>由于在创建容器时使用了<code>--rm</code>选项，容器在停止时会被移除，当我们使用下面的命令查看所有容器时，应该已经看不到刚才的<code>mynginx</code>容器了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure>
<p>如果在创建容器时没有指定<code>--rm</code>选项，那么也可以使用下面的命令来删除容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm mynginx</span><br></pre></td></tr></table></figure>
<p>要删除正在运行中的容器，需要使用<code>-f</code>选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f mynginx</span><br></pre></td></tr></table></figure>
<h4 id="运行MySQL">运行MySQL</h4>
<p>我们再来尝试用Docker安装一台MySQL服务器，首先可以先检查一下有没有MySQL的镜像文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INDEX        NAME            DESCRIPTION        STARS        OFFICIAL        AUTOMATED</span><br><span class="line">docker.io    docker.io/mysql MySQL is a ...     8486         [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：上面查询结果的列依次代表索引、镜像名、镜像描述、用户评价、是否官方镜像、自动构建。</p>
</blockquote>
<p>下载MySQL镜像并指定镜像的版本号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<p>如果需要查看已经下载的镜像文件，可以使用下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/nginx     latest              e445ab08b2be        2 weeks ago         126 MB</span><br><span class="line">docker.io/mysql     5.7                 f6509bac4980        3 weeks ago         373 MB</span><br></pre></td></tr></table></figure>
<p>创建并运行MySQL容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name mysql57 -v /root/docker/mysql/conf:/etc/mysql/mysql.conf.d -v /root/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上面创建容器时我们又一次使用了数据卷操作，那是因为通常容器是随时创建随时删除的，而数据库中的数据却是需要保留下来的。</p>
</blockquote>
<p>上面的两个数据卷操作一个是映射了MySQL配置文件所在的文件夹，一个是映射了MySQL数据所在的文件夹，这两个数据卷操作非常重要。我们可以将MySQL的配置文件放在<code>$PWD/mysql/conf</code>目录下，配置文件的具体内容如下所示：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">pid-file</span>=/var/run/mysqld/mysqld.pid</span><br><span class="line"><span class="attr">socket</span>=/var/run/mysqld/mysqld.sock</span><br><span class="line"><span class="attr">datadir</span>=/var/lib/mysql</span><br><span class="line"><span class="attr">log-error</span>=/var/log/mysql/error.log</span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">log-bin</span>=/var/log/mysql/mysql-bin.log</span><br><span class="line"><span class="attr">expire_logs_days</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="number">256</span>M</span><br><span class="line"><span class="attr">symbolic-links</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果安装了MySQL 8.x版本（目前的最新版本），在使用客户端工具连接服务器时可能会遇到<code>error 2059: Authentication plugin 'caching_sha2_password' cannot be loaded</code>的问题，这是因为MySQL 8.x默认使用了名为“caching_sha2_password”的机制对用户口令进行了更好的保护，但是如果客户端工具不支持新的认证方式，连接就会失败。解决这个问题有两种方式：一是升级客户端工具来支持MySQL 8.x的认证方式；二是进入容器，修改MySQL的用户口令认证方式。下面是具体的步骤，我们先用<code>docker exec</code>命令进入容器的交互式环境，假设运行MySQL 8.x的容器名字叫<code>mysql8x</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql8x /bin/bash</span><br></pre></td></tr></table></figure>
<p>进入容器的交互式Shell之后，可以首先利用MySQL的客户端工具连接MySQL服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password:</span><br><span class="line">Your MySQL connection id is 16</span><br><span class="line">Server version: 8.0.12 MySQL Community Server - GPL</span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"><span class="meta prompt_">mysql&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来通过SQL来修改用户口令就可以了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span> password expire never;</span><br></pre></td></tr></table></figure>
<p>当然，如果愿意你也可以查看一下用户表检查是否修改成功。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>, host, plugin, authentication_string <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+-----------------------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span> <span class="operator">|</span> host      <span class="operator">|</span> plugin                <span class="operator">|</span> authentication_string                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+-----------------------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> root <span class="operator">|</span> <span class="operator">%</span>         <span class="operator">|</span> mysql_native_password <span class="operator">|</span> <span class="operator">*</span><span class="number">6</span>BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> root <span class="operator">|</span> localhost <span class="operator">|</span> mysql_native_password <span class="operator">|</span> <span class="operator">*</span><span class="number">6</span>BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+-----------------------+-------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>在完成上面的步骤后，现在即便不更新客户端工具也可以连接MySQL 8.x了。</p>
<h4 id="运行Redis">运行Redis</h4>
<p>接下来我们试一试运行多个容器并让多个容器之间通过网络通信。我们创建4个Redis容器来实现一主三从的主从复制结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis-master redis</span><br><span class="line">docker run -d -p 6380:6379 --name redis-slave-1 --link redis-master:redis-master redis redis-server --replicaof redis-master 6379</span><br><span class="line">docker run -d -p 6381:6379 --name redis-slave-2 --link redis-master:redis-master redis redis-server --replicaof redis-master 6379</span><br><span class="line">docker run -d -p 6382:6379 --name redis-slave-3 --link redis-master:redis-master redis redis-server --replicaof redis-master 6379</span><br></pre></td></tr></table></figure>
<p>上面的命令中，<code>--link</code>参数用于给容器创建网络别名，因为三台从机（slave）需要通过网络连接自己的主机（master）。虽然，我们可以通过<code>docker inspect --format '&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;' &lt;container-ID&gt;</code>命令来查看到容器的IP地址，但是由于容器的即装即用性，容器的IP地址有可能会发生变化，如果直接使用IP地址，在容器重启后就可能会因为IP地址的变化导致从机无法连接到主机。使用<code>--link</code>参数创建网络别名就是为了在启动Redis服务器时在<code>redis-server</code>后面的<code>--replicaof</code>参数后使用这个别名而不是IP地址。</p>
<p>接下来我们进入名为<code>redis-master</code>的容器，看看主从复制的配置是否成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-master /bin/bash</span><br></pre></td></tr></table></figure>
<p>通过<code>redis-cli</code>启动命令行工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:3</span><br><span class="line">slave0:ip=172.17.0.4,port=6379,state=online,offset=1988,lag=0</span><br><span class="line">slave1:ip=172.17.0.5,port=6379,state=online,offset=1988,lag=1</span><br><span class="line">slave2:ip=172.17.0.6,port=6379,state=online,offset=1988,lag=1</span><br><span class="line">master_replid:94703cfa03c3ddc7decc74ca5b8dd13cb8b113ea</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1988</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:1988</span><br></pre></td></tr></table></figure>
<h4 id="运行GitLab">运行GitLab</h4>
<p>GitLab是由GitLab Inc.开发的Git仓库管理工具，具有wiki、问题跟踪、持续集成等一系列的功能，分为社区版和企业版。通过Docker提供的虚拟化容器，我们可以安装社区版的Docker。因为GitLab需要使用SSH协议进行安全连接，我们要暴露容器的22端口，所以可以先将宿主机SSH连接的22端口修改为其他端口（如：12345），然后再进行后续的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>将其中定义端口的那行代码去掉注释并将端口修改为12345。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port 12345</span><br></pre></td></tr></table></figure>
<p>重新启动<code>sshd</code>服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：修改端口后应该确保防火墙上也开启对应的端口，否则无法使用SSH连接到Linux服务器。</p>
</blockquote>
<p>创建需要用于数据卷映射操作的文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/gitlab/&#123;config,logs,data&#125;</span><br></pre></td></tr></table></figure>
<p>基于<code>gitlab/gitlab-ce</code>镜像创建容器，并暴露80端口（HTTP连接）和22端口（SSH连接）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 -p 22:22 --name gitlab -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：GitLab的启动比较缓慢，创建好容器后可能需要等待一段时间才能通过浏览器来进行访问。</p>
</blockquote>
<p>首次进入GitLab访问界面会提示我们修改管理员密码，设置好管理员密码后就可以在登录界面输入用户名<code>root</code>和刚才设置的密码登录到管理员控制台，在使用上还是非常简单和人性化的。</p>
<h3 id="构建镜像">构建镜像</h3>
<p>通过上面的讲解，我们已经掌握了如何通过官方提供的镜像来创建容器。当然如果愿意，我们也可以用配置好的容器来生成镜像。简而言之，<strong>Docker镜像是由文件系统叠加而成的，系统的最底层是bootfs，相当于就是Linux内核的引导文件系统；接下来第二层是rootfs，这一层可以是一种或多种操作系统（如Debian或Ubuntu文件系统），Docker中的rootfs是只读状态的；Docker利用联合挂载技术将各层文件系统叠加到一起，最终的文件系统会包含有底层的文件和目录，这样的文件系统就是一个镜像</strong>。</p>
<p>之前我们讲过了如何查找、列出镜像和拉取（下载）镜像，接下来看看构建镜像的两种方式：</p>
<ol>
<li>使用<code>docker commit</code>命令。（不推荐）</li>
<li>使用<code>docker build</code>命令和Dockerfile文件。</li>
</ol>
<h4 id="使用commit命令构建镜像">使用commit命令构建镜像</h4>
<p>为了演示如何构建镜像，我们先使用Ubuntu镜像来定制一个容器，命令如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name myubuntu -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>在容器中执行下面的命令来安装Apache服务器并退出容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt -y upgrade</span><br><span class="line">apt -y install apache2</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>我们将这个容器作为一个定制的Web服务器保存起来，当需要这样一台Web服务器的时候，就没有必要重新创建容器并安装Apache了。</p>
<p>首先我们通过下面的命令查看容器的ID。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID    IMAGE    COMMAND        CREATED        STATUS        PORTS    NAMES</span><br><span class="line">014bdb321612    ubuntu   &quot;/bin/bash&quot;    5 minutes ago  Exited (0)             myubuntu</span><br></pre></td></tr></table></figure>
<p>提交定制的容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 014bdb321612 jackfrued/mywebserver</span><br></pre></td></tr></table></figure>
<p>查看镜像文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY              TAG       IMAGE ID        CREATED             SIZE</span><br><span class="line">jackfrued/mywebserver   latest    795b294d265a    14 seconds ago      189 MB</span><br></pre></td></tr></table></figure>
<p>生成镜像文件以后，后面就可以利用刚才创建的镜像文件来创建新的容器。</p>
<h4 id="使用Dockerfile构建镜像">使用Dockerfile构建镜像</h4>
<p>Dockerfile使用DSL（Domain Specific Language）来构建一个Docker镜像，只要编辑好了Dockerfile文件，就可以使用<code>docker build</code>命令来构建一个新的镜像。</p>
<p>我们先创建一个名为myapp的文件夹来保存项目代码和Dockerfile的文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ECS-root temp]# tree myapp</span><br><span class="line">myapp</span><br><span class="line">├── api</span><br><span class="line">│   ├── app.py</span><br><span class="line">│   ├── requirements.txt</span><br><span class="line">│   └── start.sh</span><br><span class="line">└── Dockerfile</span><br></pre></td></tr></table></figure>
<p>其中api是Flask项目的文件夹，其中包括了项目代码、依赖项以及启动脚本等文件，具体内容如下所示：</p>
<p><code>app.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> Resource, Api</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">CORS(app, resources=&#123;<span class="string">r&#x27;/api/*&#x27;</span>: &#123;<span class="string">&#x27;origins&#x27;</span>: <span class="string">&#x27;*&#x27;</span>&#125;&#125;)</span><br><span class="line">api = Api(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(<span class="title class_ inherited__">Resource</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        products = [<span class="string">&#x27;Ice Cream&#x27;</span>, <span class="string">&#x27;Chocolate&#x27;</span>, <span class="string">&#x27;Coca Cola&#x27;</span>, <span class="string">&#x27;Hamburger&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;products&#x27;</span>: products&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">api.add_resource(Product, <span class="string">&#x27;/api/products&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>requirements.txt</code>文件：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">flask-restful</span><br><span class="line">flask-cors</span><br><span class="line">gunicorn</span><br></pre></td></tr></table></figure>
<p><code>start.sh</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">exec gunicorn -w 4 -b 0.0.0.0:8000 app:app</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：需要给start.sh文件以执行权限，可以使用<code>chmod 755 start.sh</code>命令来做到。</p>
</blockquote>
<p>Dockerfile文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span></span><br><span class="line"><span class="comment"># 指定镜像的维护者</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> jackfrued <span class="string">&quot;jackfrued@126.com&quot;</span></span><br><span class="line"><span class="comment"># 将指定文件添加到容器中指定的位置</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> api/* /root/api/</span></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/api</span></span><br><span class="line"><span class="comment"># 执行命令(安装Flask项目的依赖项)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt -i https://pypi.doubanio.com/simple/</span></span><br><span class="line"><span class="comment"># 容器启动时要执行的命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;./start.sh&quot;</span>]</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure>
<p>我们来解释一下上面的Dockerfile文件。Dockerfile文件通过特殊的指令来指定基础镜像（FROM指令）、创建容器后需要指定的命令（RUN指令）以及需要暴露的端口（EXPOSE）等信息。我们稍后会专门为大家介绍这些Dockfile中的指令。</p>
<p>接下来我们可以使用<code>docker build</code>命令来创建镜像，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t &quot;jackfrued/myapp&quot; .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：上面的命令最后面的<code>.</code> 千万不要漏掉了哦，它表示从当前路径下寻找Dockerfile。</p>
</blockquote>
<p>通过下面的命令可以查看创建好的镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">jackfrued/myapp              latest              6d6f026a7896        5 seconds ago       930 MB</span><br></pre></td></tr></table></figure>
<p>如果想知道镜像文件是如何创建出来的，可以使用下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker history jackfrued/myapp</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">6d6f026a7896        31 seconds ago      /bin/sh -c #(nop)  EXPOSE 8000/tcp              0 B                 </span><br><span class="line">3f7739173a79        31 seconds ago      /bin/sh -c #(nop)  ENTRYPOINT [&quot;./start.sh&quot;]    0 B                 </span><br><span class="line">321e6bf09bf1        32 seconds ago      /bin/sh -c pip install -r requirements.txt...   13 MB               </span><br><span class="line">2f9bf2c89ac7        37 seconds ago      /bin/sh -c #(nop) WORKDIR /root/api             0 B                 </span><br><span class="line">86119afbe1f8        37 seconds ago      /bin/sh -c #(nop) ADD multi:4b76f9c9dfaee8...   870 B               </span><br><span class="line">08d465e90d4d        3 hours ago         /bin/sh -c #(nop)  MAINTAINER jackfrued &quot;j...   0 B                 </span><br><span class="line">fbf9f709ca9f        12 days ago         /bin/sh -c #(nop)  CMD [&quot;python3&quot;]              0 B </span><br></pre></td></tr></table></figure>
<p>使用该镜像来创建容器运行Web服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8000:8000 --name myapp jackfrued/myapp</span><br></pre></td></tr></table></figure>
<p>如果希望将上面创建的镜像文件放到dockerhub仓库中，可以按照如下所示的步骤进行操作。</p>
<p>通过下面的命令登录到dockerhub。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>
<p>输入用户名和口令进行登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: jackfrued</span><br><span class="line">Password: </span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>
<p>通过下面的命令将镜像推到仓库中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push jackfrued/webserver</span><br></pre></td></tr></table></figure>
<p><img src="./res/dockerhub-repo.png" alt=""></p>
<h4 id="Dockerfile指令">Dockerfile指令</h4>
<p>想了解Dockerfile的指令可以查看官方提供的<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">参考手册</a>，下面我们为大家介绍一些常用的指令。</p>
<ol>
<li>
<p><strong>FROM</strong>：设置基础镜像，必须是Dockerfile中的第一条指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;镜像名&gt; [AS &lt;别名&gt;]</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;镜像名&gt;[:&lt;标签&gt;] [AS &lt;别名&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>RUN</strong>：指定构建镜像时要执行的命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;命令&gt; [参数1], [参数2], ... </span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>, ...]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>CMD</strong>：指定构建镜像后要执行的命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> &lt;命令&gt; [参数1], [参数2], ...</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>, ...]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：Docker不同于虚拟机，容器本身就是一个进程，容器中的应用应该位于前台运行。CMD命令相当于就是用来指定容器主进程（创建容器后要在前台执行的程序）的，如果主进程结束了，容器也就停止运行了。所以在容器中启动Nginx不能使用<code>service nginx start</code>或是<code>systemctl start nginx</code>而是要通过<code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code>让它在前台运行。</p>
</blockquote>
</li>
<li>
<p><strong>ENTRYPOINT</strong>：和CMD类似，也可以执行命令，但<code>docker run</code>命令行中指定的任何参数都会被当做参数再次传给ENTRYPOINT指令中的命令，这就使得我们可以构建一个镜像，它既可以运行一个默认的命令，也支持通过<code>docker run</code>命令行为该命令指定可覆盖的参数选项。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> &lt;命令&gt; [参数1], [参数2], ...</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>, ...]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>WORKDIR</strong>：在通过镜像创建新容器时，在容器内部创建一个工作目录，ENTRYPOINT和CMD指定的程序会在这个目录下执行。在使用<code>docker run</code>命令时可以通过<code>-w</code>参数来覆盖由WORKDIR指定的工作目录。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/webapp</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -w /usr/share/webapp ...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>ENV</strong>：在创建镜像时设置环境变量。在使用<code>docker run</code>命令时，可以通过<code>-e</code>参数来修改环境变量的设置。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DEFAULT_PORT=<span class="number">8080</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -e &quot;DEFAULT_PORT=8000&quot; ...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>USER</strong>：指定镜像会以什么用户身份去运行。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> nginx</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>VOLUME</strong>：在创建容器时添加一个数据卷的挂载点。通过数据卷操作可以实现容器间数据的共享和重用，对卷所作的修改可以马上生效而不需要重新启动容器，我们之前创建容器时使用<code>--volume</code>参数就是为了实现数据卷的映射操作。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/路径1&quot;</span>, <span class="string">&quot;/路径2/子路径2.1/&quot;</span>, ...]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>ADD</strong>：将构建目录下的文件和文件夹复制到镜像中，如果是压缩文件和归档文件，ADD命令会对这些文件进行解压缩解归档的操作。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;用户&gt;:&lt;用户组&gt;] &lt;源文件&gt; &lt;目标文件&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>COPY</strong>：非常类似于ADD，但不会主动对文件进行提取操作。</p>
</li>
<li>
<p><strong>LABEL</strong>：为Docker镜像添加一些元数据，在使用<code>docker inspect</code>命令时会看到这些元数据。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0.0&quot;</span> location=<span class="string">&quot;Chengdu&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>ONBUILD</strong>：为镜像添加触发器，当一个镜像被用作其他镜像的基础镜像，触发器将会被执行。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span><span class="language-bash"> . /app/src</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app/src &amp;&amp; make</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="多容器管理">多容器管理</h3>
<p>我们的项目可能会使用了多个容器，容器多了之后管理容器的工作就会变得麻烦。如果要对多个容器进行自动配置使得容器可以相互协作甚至实现复杂的调度，这就需要进行容器编排。Docker原生对容器编排的支持非常弱，但是可以通过社区提供的工具来实现容器编排。</p>
<h4 id="Docker-Compose">Docker Compose</h4>
<p>可以通过安装Docker Compose工具来实现基于YAML文件的容器编排，YAML文件会定义一系列的容器以及容器运行时的属性，Docker Compose会根据这些配置来管理容器。</p>
<ol>
<li>
<p>安装Docker Compose。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：如果没有curl工具，在CentOS下可以先通过包管理工具yum安装curl再执行上面的命令。</p>
</blockquote>
<p>当然我们也可以使用Python的包管理工具pip来安装Docker Compose，命令如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install -U docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用Docker Compose。</p>
<p>我们在刚才的Flask项目中引入缓存，然后再利用Flask提供的数据接口为前端页面提供数据，使用Vue.js进行页面渲染并将静态页面部署在Nginx服务器上。项目文件夹结构如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ECS-root ~]# tree temp</span><br><span class="line">temp</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── html</span><br><span class="line">│   └── index.html</span><br><span class="line">└── myapp</span><br><span class="line">    ├── api</span><br><span class="line">    │   ├── app.py</span><br><span class="line">    │   ├── requirements.txt</span><br><span class="line">    │   └── start.sh</span><br><span class="line">    └── Dockerfile</span><br></pre></td></tr></table></figure>
<p>修改后的app.py文件代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pickle <span class="keyword">import</span> dumps, loads</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> Resource, Api</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">CORS(app, resources=&#123;<span class="string">r&#x27;/api/*&#x27;</span>: &#123;<span class="string">&#x27;origins&#x27;</span>: <span class="string">&#x27;*&#x27;</span>&#125;&#125;)</span><br><span class="line">api = Api(app)</span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redis-master&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(<span class="title class_ inherited__">Resource</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        data = redis.get(<span class="string">&#x27;products&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            products = loads(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            products = [<span class="string">&#x27;Ice Cream&#x27;</span>, <span class="string">&#x27;Chocolate&#x27;</span>, <span class="string">&#x27;Coca Cola&#x27;</span>, <span class="string">&#x27;Hamburger&#x27;</span>]</span><br><span class="line">            redis.<span class="built_in">set</span>(<span class="string">&#x27;products&#x27;</span>, dumps(products))</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;products&#x27;</span>: products&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">api.add_resource(Product, <span class="string">&#x27;/api/products&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>html文件夹用来保存静态页面，稍后我们会通一个运行Nginx的容器来向浏览器提供静态页面。index.html文件的内容如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>产品列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;product in products&quot;</span>&gt;</span>&#123;&#123; product &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">products</span>: []</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">fetch</span>(<span class="string">&#x27;http://1.2.3.4:8000/api/products&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                    .<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> resp.<span class="title function_">json</span>())</span></span><br><span class="line"><span class="language-javascript">                    .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;<span class="variable language_">this</span>.<span class="property">products</span> = json.<span class="property">products</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们要通过docker-compose.yml文件来创建三个容器并指明容器之间的依赖关系。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">api-server:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./myapp</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8000:8000&#x27;</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-master</span></span><br><span class="line">  <span class="attr">web-server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./html:/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">redis-master:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;6379&#x27;</span></span><br></pre></td></tr></table></figure>
<p>有了这个YAML文件，我们就可以使用<code>docker-compose</code>命令来创建容器运行项目，其命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ECS-root temp]# docker-compose up</span><br><span class="line">Creating network &quot;temp_default&quot; with the default driver</span><br><span class="line">Creating temp_web-server_1   ... done</span><br><span class="line">Creating temp_redis-master_1 ... done</span><br><span class="line">Creating temp_api-server_1   ... done</span><br><span class="line">Attaching to temp_redis-master_1, temp_web-server_1, temp_api-server_1</span><br><span class="line">redis-master_1  | 1:C 05 Dec 2019 11:57:26.828 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">redis-master_1  | 1:C 05 Dec 2019 11:57:26.828 # Redis version=5.0.6, bits=64, commit=00000000, modified=0, pid=1, just started</span><br><span class="line">redis-master_1  | 1:C 05 Dec 2019 11:57:26.828 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span><br><span class="line">redis-master_1  | 1:M 05 Dec 2019 11:57:26.830 * Running mode=standalone, port=6379.</span><br><span class="line">redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 # Server initialized</span><br><span class="line">redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span><br><span class="line">redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 * Ready to accept connections</span><br><span class="line">api-server_1    | [2019-12-05 11:57:27 +0000] [1] [INFO] Starting gunicorn 20.0.4</span><br><span class="line">api-server_1    | [2019-12-05 11:57:27 +0000] [1] [INFO] Listening at: http://0.0.0.0:8000 (1)</span><br><span class="line">api-server_1    | [2019-12-05 11:57:27 +0000] [1] [INFO] Using worker: sync</span><br><span class="line">api-server_1    | [2019-12-05 11:57:27 +0000] [8] [INFO] Booting worker with pid: 8</span><br><span class="line">api-server_1    | [2019-12-05 11:57:27 +0000] [9] [INFO] Booting worker with pid: 9</span><br><span class="line">api-server_1    | [2019-12-05 11:57:27 +0000] [10] [INFO] Booting worker with pid: 10</span><br><span class="line">api-server_1    | [2019-12-05 11:57:27 +0000] [11] [INFO] Booting worker with pid: 11</span><br></pre></td></tr></table></figure>
<p>要停止容器的运行，可以使用下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Kubernetes（K8S）">Kubernetes（K8S）</h4>
<p>实际的生产环境中常常需要部署和管理多个协同工作的容器，docker compose解决了多容器创建和管理的问题，但是实际项目中，我们还需要Kubernetes（以下都简称为K8S）来提供一个跨主机集群的容器调度平台。K8S可以进行自动化容器的部署、扩展和操作，从而提供以容器为中心的基础架构。该项目是谷歌在2014年启动的项目，建立在谷歌公司十余年运维经验的基础之上，而且谷歌自己的应用也是运行在容器上的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yuanweize.github.io">GreenSeaa</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yuanweize.github.io/2022/08/09/Python-100-Days/Day91-100/92.Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/">https://yuanweize.github.io/2022/08/09/Python-100-Days/Day91-100/92.Docker容器技术详解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yuanweize.github.io" target="_blank">HExLL</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/Day91-100/">Day91-100</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/09/Python-100-Days/Day91-100/91.%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">91.团队项目开发的问题和解决方案</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/09/Python-100-Days/Day91-100/93.MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">93.MySQL性能优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/09/Python-100-Days/Day91-100/100.Python%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E5%BD%95/" title="100.Python面试题实录"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 09-08-2022</div><div class="title">100.Python面试题实录</div></div></a></div><div><a href="/2022/08/09/Python-100-Days/Day91-100/91.%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="91.团队项目开发的问题和解决方案"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 09-08-2022</div><div class="title">91.团队项目开发的问题和解决方案</div></div></a></div><div><a href="/2022/08/09/Python-100-Days/Day91-100/93.MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="93.MySQL性能优化"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 09-08-2022</div><div class="title">93.MySQL性能优化</div></div></a></div><div><a href="/2022/08/09/Python-100-Days/Day91-100/94.%E7%BD%91%E7%BB%9CAPI%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/" title="94.网络API接口设计"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 09-08-2022</div><div class="title">94.网络API接口设计</div></div></a></div><div><a href="/2022/08/09/Python-100-Days/Day91-100/95.%E4%BD%BF%E7%94%A8Django%E5%BC%80%E5%8F%91%E5%95%86%E4%B8%9A%E9%A1%B9%E7%9B%AE/" title="95.使用Django开发商业项目"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 09-08-2022</div><div class="title">95.使用Django开发商业项目</div></div></a></div><div><a href="/2022/08/09/Python-100-Days/Day91-100/96.%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" title="96.软件测试和自动化测试"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 09-08-2022</div><div class="title">96.软件测试和自动化测试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s.gravatar.com/avatar/50de7ee8a1fc96ada7495a641400642d?s=512" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">GreenSeaa</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">59</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuanweize"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuanweize" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:info@hktse.cz" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://t.me/greenseaa" target="_blank" title=""><i class="fab fa-telegram"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my HELL</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">Docker容器技术详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Docker简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Docker"><span class="toc-number">1.2.</span> <span class="toc-text">安装Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Docker"><span class="toc-number">1.3.</span> <span class="toc-text">使用Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8CNginx"><span class="toc-number">1.3.1.</span> <span class="toc-text">运行Nginx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8CMySQL"><span class="toc-number">1.3.2.</span> <span class="toc-text">运行MySQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8CRedis"><span class="toc-number">1.3.3.</span> <span class="toc-text">运行Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8CGitLab"><span class="toc-number">1.3.4.</span> <span class="toc-text">运行GitLab</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.</span> <span class="toc-text">构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8commit%E5%91%BD%E4%BB%A4%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">使用commit命令构建镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用Dockerfile构建镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.3.</span> <span class="toc-text">Dockerfile指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">多容器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">1.5.1.</span> <span class="toc-text">Docker Compose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes%EF%BC%88K8S%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">Kubernetes（K8S）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/09/Markdow-emoji/" title="Markdown语法介绍_Emoji表情">Markdown语法介绍_Emoji表情</a><time datetime="2022-08-09T19:22:47.000Z" title="发表于 09-08-2022 21:22:47">09-08-2022</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/09/Markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/" title="Markdown语法介绍_README文件语法解读">Markdown语法介绍_README文件语法解读</a><time datetime="2022-08-09T19:22:47.000Z" title="发表于 09-08-2022 21:22:47">09-08-2022</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/09/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6-EN/" title="自学计算机科学_EN">自学计算机科学_EN</a><time datetime="2022-08-09T19:18:12.000Z" title="发表于 09-08-2022 21:18:12">09-08-2022</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/09/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6-CN/" title="自学计算机科学_CN">自学计算机科学_CN</a><time datetime="2022-08-09T19:18:04.000Z" title="发表于 09-08-2022 21:18:04">09-08-2022</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/09/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/" title="提问的智慧">提问的智慧</a><time datetime="2022-08-09T19:15:07.000Z" title="发表于 09-08-2022 21:15:07">09-08-2022</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By GreenSeaa</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>